=================================
1.	Czy można przekazywać Optional w argumentach metody?
	Nie powinno się. Używanie tak Optionali zaciemnia zapis metody,
	sprawia że działanie metody zależy od wartości optionala,
	optional w porównaniu do nullowalnych argumentów jest bardziej kosztowny,
	Optional może reprezentować aż trzy różne stany: null, non-null ale isPresent = false,
	oraz non-null opakowujący właściwą wartość.

2.	Skoro nie to jak można obsłużyć zmienną która może być nullem?
	Najbardziej eleganckim rozwiązaniem jest stworzenie overloadowanej metody
	obsługującej wariant logiki z argumentem null.

3.	Jaka lista jeżeli chcę dodawać dane zawsze na początku?
	Klasa LinkedList posiada w sobie metody `addFirst()` oraz `addLast()` 

4.	Co to jest LinkedList?
	Podwójnie łączona lista danych - każdy jej node przechowuje informacje
	o swojej zawartości, jak i odnośniki do node przed i za nim.

5.	Co wprowadziła Java 8?
	- 	Streamy
	- 	Wyrażenia lambda
	- 	Interfejsy funkcyjne
	-	Try-with-resources
	-	Optionale
	-	Typy generyczne

6.	Trzy interfejsy funkcyjne i opisać je
	- Function: przyjmuje jeden argument i zwraca jeden argument
	-	Customer: przyjmuje jeden argument i nie zwraca nic
	-	Predicate: przyjmuje jeden argument i wywołuje na nim test logiczny

7.	Map vs flatMap w Streamach
	-	Map służy do mapowania wartości w streamie na inne wartości przy użyciu
		interfejsu funkcyjnego Function
	-	flatMap używamy w momencie kiedy musimy "spłaszczyć" rezultat działania,
		tzn: jeżeli mamy np. nested stream, kolekcję lub optional 
		Optional.of(Optional.of(foo)) lub List<List<String>> 
		to używając flatMap możemy to spłaszczyć do Optional.of(foo) i List<String>

8.	Jak sprawić żeby obiekt był Immutable?
	-	Ustawić pola jako `private final`
	-	Gettery zwracające nie bezpośrednią referncję do obiektu, ale jego kopię (klon)
	-	Ustawić klase jako `final`
	-	Nie tworzyć setterów do pól
	-	Inicjalizacja pól z argumentów konstruktora powinna odbywać się
		przez deep copy tych arugmentów na pola

9.	Jak przekazać do obiektu immutable przez konstruktor np. mapę?
	Aby wypełnić immutable pole taką mapą należy jej zawartość skopiować do tego pola
	(deep copy)

10.	Jak działa HashMapa?
	-	HashMapa przy inicjalizacji tworzy serię pustych bucketów (domyślnie 16),
		z których każdy może mieć jeden lub więcej nodów połączonych jak LinkedList.
	-	Przy dodawaniu elementu HashMap oblicza hashCode klucza i potem używając
			`index = hash & (n-1)`
			gdzie `n` to ilość bucketów
		(klucz `null` wyląduje w bucket 0)
		ustala index bucketa, do którego wrzuci dany obiekt.
	-	Każdy node będzie zawierał: 
		- key
		- hashcode
		- value
		- next //referencja do następnego node

11.	a) Czy można dodać do HashMapy dwa klucze o tym samym hashu?
	b) Czy możemy zmienić hashcode już istniejącego w mapie obiektu?
	c) Co się wtedy stanie?
	ad a) 	Można dodać, trafią wtedy do tego samego bucketa i połączą się w LinkedList.
	ab b,c)	Możemy, ale nie powinno się tego robić, bo psuje to mapę i obiekt o zmienionym
			hashcode nie będzie już dostępny. Najlepiej jeżeli obiekty używane jako klucze
			będą immutable.

12.	Jak definiujemy beany w Springu? Jaki jest ich domyślny scope?
		a) w pliku XML
		b) od Spring 2.5 - annotacje 
						Annotacje są rozpatrywane przed XMLem, więc XML je nadpisze
		c) Java-Based: zrobienie klasy @Configuration i w niej definiowanie metod
						@Bean które zwracają beany danej klasy
		Domyślny Scope beanów to Singleton. Ale nie jest to taki singleton jak zwykły singleton.
		Scope Singleton oznacza tyle że zawsze kiedy wywołamy beana o id X
		to dostaniemy ten sam obiekt, a nie nowy. 
		Jeżeli chcielibyśmy dostawać nowy obiekt to od tego jest Scope Prototype.

13.	Dlaczego powstał SpringBoot?
				Spring Boot automatyzuje i ułatwia konfigurowanie potrzebnych elementów 
				np. do stworzenia Web Serwisu (konfiguracja kontekstu servletów) czy Spring Data
				(konfiguracja entity managera, transaction managera itd)
		
14.	Różnica między Post a Put, czy Putem możemy umiesczać nowe dane na serwerze?
				Super artykuły o tym:
				https://codecouple.pl/2017/06/09/15-spring-boot-post-put-czy-patch/	
				https://stackoverflow.com/questions/630453/put-vs-post-in-rest

				- POST: używany do tworzenia nowego zasobu kiedy jego np ID nie jest jeszcze znane
												id będzie przydzielone przez serwer w czasie tworzenia obiektu.
												** Po utworzeniu obiektu należy zwrócić kod 201 “Created”. **
				- PUT: może być używany i do tworzenia i aktualizowania danych na serwerze,
												kiedy ID obiektu jest już znane i można je przekazać w parametrach requestu
												** Po aktualizacji należy zwróć kod 204 “No content”. **
				- PATCH: używany do updejtowania tylko części obiektu którego ID jest znane
												** Po aktualizacji należy zwróć kod 204 “No content”. **

15.	Annotacje @Controller, @Repository, @Service - co oznaczają pod maską?
				@Controller:		oprócz zwykłego @Component sprawia też że DispatchServlet będzie uwzględniał
																		tę klasę kiedy będzie szukał klas z @RequestMapping	
				@Repository:		zapewnia obłusługę platform-dependent błędów i tłumaczenie ich na 
																		ogólne błędy springowe
				@Service:					nie nie robi na razie
16.	Obsługa wyjątków w Springu
				
17.	Optimistic vs Pesimistic locking w Hibernate
				-	Pessimistic:	aplikacja zamyka dostęp do bazy danych oprócz danej transakcji
										bezpieczniejsze niż optimistic, ale aplikacja musi być odpowiednio
										zaprojketowana żeby z niego korzystać
				-	Optimistic:		wiele transakcji ma dostęp do bazy danych. przed updatem
										transakcja sprawdza czy versionNo i timeStamp są takie same
										jak te odczytane przy połączeniu. jeżeli nie to wie że dane 
										sa skażone i anulują tę transakcję
18.	Kiedy Hibernate rzuca LazyInitializationException
19.	Kiedy używać indeksowania baz danych
				PytaniaJava
20.	Wady indeksowania
				PytaniaJava
21.	Jakie kody komunkatów HTTP znasz
22. Czym różnią się kody 400 od kodów 500?
23. Co oznacza S w skrócie SOLID
24.	Jak zbadać czy klasa narusza S
25.	Czym się różni Spy od Mock
26.	Jeżeli metoda nic nie zwraca to jak ją obsłużyć w testach?
27.	Jak sprawdzić czy metoda która nic nie zwraca została wywołana w teście?
28.	Dlaczego JIT Compiler JVM nazywa się HotSpot
	Bo cały czas analizuje kod programu szukając `hot spotów` czyli fragmentów kodu
	wykonywanych często lub powtarzających się i te elementy `just-in-time` kompiluje
	do kodu maszynowego
29.	Aspect Oriented Programming w Springu
30.	Czy w Javie występuje polimortizm pól
	Nie, pola są chowane, metody overridowane
